pragma solidity >=0.4.21 <0.6.0;

contract SupplyChain is AccessControl, Ownable{

  address owner;

  // Define a variable called 'upc' for Universal Product Code (UPC)
  uint  upc;

  // // Define a variable called 'sku' for Stock Keeping Unit (SKU)
  // uint  sku;

  // Define a public mapping 'items' that maps the UPC to an Item.
  mapping (uint => Item) items;

  // Define a public mapping 'itemsHistory' that maps the UPC to an array of TxHash,
  // that track its journey through the supply chain -- to be sent from DApp.
  mapping (uint => string[]) itemsHistory;

  // Define enum 'State' with the following values:
  enum State
  {
    Donated,  // 0
    Collected,  // 1
    Tested,     // 2
    Processed,    // 3
    Packed,       // 4
    Stored,    // 5
    Administered,   // 6
    Received   // 7
  }

  enum BloodType {
    Ap,  //A-positive
    An,
    Bp,
    Bn,
    ABp,
    ABn,
    Op,
    On
  }

  State constant defaultState = State.Donated;

  // Define a struct 'Item' with the following fields:
  struct Item {
    // uint    sku;  // Stock Keeping Unit (SKU)
    uint    upc; // Universal Product Code (UPC), generated by the Donor, goes on the package, can be verified by the Patien
    address ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
    address donorID; // Metamask-Ethereum address of the Donor
    string  donorName; // Donor Name
    string  donorInformation;  // Donor Information
    BloodType  bloodType; // Blood Type
    State   itemState;  // Product State as represented in the enum above
    address processingCenterID;  // Metamask-Ethereum address of the processing center
    address hospitalID; // Metamask-Ethereum address of the Hospital
    address patientID; // Metamask-Ethereum address of the Patient
  }

  // Define 8 events with the same 8 state values and accept 'upc' as input argument
  event Donated(uint upc);
  event Collected(uint upc);
  event Tested(uint upc);
  event Processed(uint upc);
  event Packed(uint upc);
  event Stored(uint upc);
  event Administered(uint upc);
  event Received (uint upc);

  // Define a modifer that checks to see if msg.sender == owner of the contract
  modifier onlyOwner() {
    require(msg.sender == owner, "Only the owner can call the function");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Donated
  modifier donated(uint _upc) {
    require(items[_upc].itemState == State.Donated, "The itemState must be Donated");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Collected
  modifier collected(uint _upc) {
    require(items[_upc].itemState == State.Collected, "The itemState must be Collected");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Tested
  modifier tested(uint _upc) {
    require(items[_upc].itemState == State.Tested, "The itemState must be Tested");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Processed
  modifier processed(uint _upc) {
    require(items[_upc].itemState == State.Processed, "The itemState must be Processed");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Packed
  modifier packed(uint _upc) {
    require(items[_upc].itemState == State.Packed, "The itemState must be Packed");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Stored
  modifier stored(uint _upc) {
    require(items[_upc].itemState == State.Stored, "The itemState must be Stored");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Administered
  modifier administered(uint _upc) {
    require(items[_upc].itemState == State.Administered, "The itemState must be Administered");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Received
  modifier received(uint _upc) {
    require(items[_upc].itemState == State.Received, "The itemState must be Received");
    _;
  }

  // In the constructor set 'owner' to the address that instantiated the contract
  // and set 'upc' to 1
  constructor() public payable {
    owner = msg.sender;
    upc = 1;
  }

  // Define a function 'kill' if required
  function kill() public {
    if (msg.sender == owner) {
      selfdestruct(owner);
    }
  }

  // Define a function 'donate' that allows a donor to mark an item 'Donated'
  function donate(string memory _donorName, string memory _donorInformation,
        BloodType _bloodType) public
  {
    Item memory newItem;

    newItem.upc = upc;
    newItem.ownerID = msg.sender;
    newItem.donorID = msg.sender;
    newItem.donorName = _donorName;
    newItem.donorInformation = _donorInformation;
    newItem.bloodType = _bloodType;
    newItem.itemState = State.Donated;

    // Emit the appropriate event
    emit Donated(upc);

    upc = upc + 1;
  }

  // Define a function 'processtItem' that allows a farmer to mark an item 'Processed'
  function processItem(uint _upc) public 
  // Call modifier to check if upc has passed previous supply chain stage
  
  // Call modifier to verify caller of this function
  
  {
    // Update the appropriate fields
    
    // Emit the appropriate event
    
  }

  // Define a function 'packItem' that allows a farmer to mark an item 'Packed'
  function packItem(uint _upc) public 
  // Call modifier to check if upc has passed previous supply chain stage
  
  // Call modifier to verify caller of this function
  
  {
    // Update the appropriate fields
    
    // Emit the appropriate event
    
  }

  // Define a function 'sellItem' that allows a farmer to mark an item 'ForSale'
  function sellItem(uint _upc, uint _price) public 
  // Call modifier to check if upc has passed previous supply chain stage
  
  // Call modifier to verify caller of this function
  
  {
    // Update the appropriate fields
    
    // Emit the appropriate event
    
  }

  // Define a function 'buyItem' that allows the disributor to mark an item 'Sold'
  // Use the above defined modifiers to check if the item is available for sale, if the buyer has paid enough, 
  // and any excess ether sent is refunded back to the buyer
  function buyItem(uint _upc) public payable 
    // Call modifier to check if upc has passed previous supply chain stage
    
    // Call modifer to check if buyer has paid enough
    
    // Call modifer to send any excess ether back to buyer
    
    {
    
    // Update the appropriate fields - ownerID, distributorID, itemState
    
    // Transfer money to farmer
    
    // emit the appropriate event
    
  }

  // Define a function 'shipItem' that allows the distributor to mark an item 'Shipped'
  // Use the above modifers to check if the item is sold
  function shipItem(uint _upc) public 
    // Call modifier to check if upc has passed previous supply chain stage
    
    // Call modifier to verify caller of this function
    
    {
    // Update the appropriate fields
    
    // Emit the appropriate event
    
  }

  // Define a function 'receiveItem' that allows the retailer to mark an item 'Received'
  // Use the above modifiers to check if the item is shipped
  function receiveItem(uint _upc) public 
    // Call modifier to check if upc has passed previous supply chain stage
    
    // Access Control List enforced by calling Smart Contract / DApp
    {
    // Update the appropriate fields - ownerID, retailerID, itemState
    
    // Emit the appropriate event
    
  }

  // Define a function 'purchaseItem' that allows the consumer to mark an item 'Purchased'
  // Use the above modifiers to check if the item is received
  function purchaseItem(uint _upc) public 
    // Call modifier to check if upc has passed previous supply chain stage
    
    // Access Control List enforced by calling Smart Contract / DApp
    {
    // Update the appropriate fields - ownerID, consumerID, itemState
    
    // Emit the appropriate event
    
  }

//   // Define a function 'fetchItemBufferOne' that fetches the data
//   function fetchItemBufferOne(uint _upc) public view returns 
//   (
//   uint    itemSKU,
//   uint    itemUPC,
//   address ownerID,
//   address originFarmerID,
//   string  originFarmName,
//   string  originFarmInformation,
//   string  originFarmLatitude,
//   string  originFarmLongitude
//   ) 
//   {
//   // Assign values to the 8 parameters
  
    
//   return 
//   (
//   itemSKU,
//   itemUPC,
//   ownerID,
//   originFarmerID,
//   originFarmName,
//   originFarmInformation,
//   originFarmLatitude,
//   originFarmLongitude
//   );
//   }

//   // Define a function 'fetchItemBufferTwo' that fetches the data
//   function fetchItemBufferTwo(uint _upc) public view returns 
//   (
//   uint    itemSKU,
//   uint    itemUPC,
//   uint    productID,
//   string  productNotes,
//   uint    productPrice,
//   uint    itemState,
//   address distributorID,
//   address retailerID,
//   address consumerID
//   ) 
//   {
//     // Assign values to the 9 parameters
  
    
//   return 
//   (
//   itemSKU,
//   itemUPC,
//   productID,
//   productNotes,
//   productPrice,
//   itemState,
//   distributorID,
//   retailerID,
//   consumerID
//   );
//   }
}